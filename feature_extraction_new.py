import fnmatch
import os.path
import argparse
import pandas as pd
import numpy as np
from androguard.misc import AnalyzeAPK
import json
import re
from db import connect_to_db
from db import get_database_name


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("-s", "--source", type=str, help="the directory of apk source folder", required=True)
    parser.add_argument("-db", "--database", default=False, action="store_true", help="use MySQL database or not",
                        required=False)
    args = parser.parse_args()

    source_folder_path = args.source
    benign_path = 'benign'
    malware_path = 'malware'

    ##start extraction processe
    benign_df = extractFeatures(source_folder_path, benign_path, args.database)
    malware_df = extractFeatures(source_folder_path, malware_path, args.database)
    output_df = benign_df.append(malware_df)
    output_df.to_csv('csv_results/extractedFeatures_new.csv', index=False)

    if args.database:
        conn = connect_to_db()
        db = conn.get_database(get_database_name())
        print("----MongoDB connected----")
        print("----INSERT into MongoDB ----")
        db.extractedFeatures_new.insert_many(json.loads(output_df.to_json(orient='records')))


def extractFeatures(source_folder_path, label_path, use_db):
    print("----- start " + label_path + " apps -----")
    ## get list of apk file
    file_list = os.listdir(source_folder_path + '/' + label_path)

    features_df = pd.DataFrame()

    ## Run extraction process if the file format is .apk
    for file in file_list:
        # check file format whether it is apk or not
        if fnmatch.fnmatch(file, '*.apk'):
            print("Run Feature extraction from {}".format(file))
            file_path = os.path.join(source_folder_path, label_path, file)
            try:
                a, d, dx = AnalyzeAPK(file_path)
            except Exception:
                print("ERROR in APK:" + file)
                continue

            static_analysis_dic = {}
            all_actions = []
            all_categories = []

            ## permission features
            try:
                permissions = list(map(lambda x: get_relevantPart_xml(x), a.get_permissions()))
                static_analysis_dic['permissions'] = deduplication(permissions)

            except UnicodeEncodeError:
                print("No permission has been extracted")

            ## intent from activity
            try:
                activities = a.get_activities()
                result_activities = extractIntentFilters(a, 'activity', activities)
                all_actions.append(result_activities['action'])
                all_categories.append(result_activities['category'])
                matched_activities = list(map(lambda x: get_relevantPart_xml(x), activities))
                static_analysis_dic['activities'] = deduplication(matched_activities)
            except UnicodeEncodeError:
                print("No activity has been extracted")

            ## intent from service
            try:
                services = a.get_services()
                result_services = extractIntentFilters(a, 'service', services)
                all_actions.append(result_services['action'])
                all_categories.append(result_services['category'])
                matched_services = list(map(lambda x: get_relevantPart_xml(x), services))
                static_analysis_dic['services'] = deduplication(matched_services)
            except UnicodeEncodeError:
                print("No service has been extracted")

            ## intent from receiver
            try:
                receivers = a.get_receivers()
                result_receivers = extractIntentFilters(a, 'receiver', receivers)
                all_actions.append(result_receivers['action'])
                all_categories.append(result_receivers['category'])
                matched_receivers = list(map(lambda x: get_relevantPart_xml(x), receivers))
                static_analysis_dic['receivers'] = deduplication(matched_receivers)
            except UnicodeEncodeError:
                print("No receiver has been extracted")

            static_analysis_dic['intent-actions'] = deduplication(np.concatenate(all_actions))
            static_analysis_dic['intent-categories'] = deduplication(np.concatenate(all_categories))

            ##Get processed bytecode from decompiler
            ##API methods
            method_list = []
            try:
                for method in dx.get_methods():
                    if method.is_external():
                        m = method.get_method()
                        method_list.append(str(m.get_name()))
                method_list = cleanAPIList(method_list)
                static_analysis_dic['API_methods'] = method_list
            except UnicodeEncodeError:
                print("Error while extracting API class")

            ##API classes including package names
            class_list = []
            try:
                for method in dx.get_methods():
                    if method.is_external():
                        m = method.get_method()
                        class_list.append(str(m.get_class_name()))
                class_list = cleanAPIList(class_list, True)
                static_analysis_dic['API_classes'] = class_list
            except UnicodeEncodeError:
                print("Error while extracting API class")

            json_features = json.dumps(static_analysis_dic)

            df = pd.DataFrame({'app_name': [a.get_package()],
                               'label': [label_path],
                               'features': [json_features]})

            features_df = features_df.append(df)
        else:
            print("wrong file format")
    return features_df


def get_relevantPart_xml(string):
    splits = string.split(".")
    return splits[len(splits) - 1]


def get_relevantPart_class(string):
    splits = string.split("/")
    return splits[len(splits) - 1]


def deduplication(feature_list):
    toset = set(feature_list)
    feature_list = list(toset)
    return feature_list


def cleanAPIList(api_list, isclass=False):
    new_api_list = []
    if isclass:
        api_list = list(map(lambda x: get_relevantPart_class(x), api_list))
    for comp in api_list:
        if isclass:
            comp = re.sub('\$(\w)+', '', comp)
            comp = re.sub(';$', '', comp)

        if re.match('^z{1,}\w*', comp) or re.match('^\$', comp):
            continue

        if len(comp) > 3 and comp[0] != '<':
            new_api_list.append(comp)

    return deduplication(new_api_list)


def extractIntentFilters(a, itemtype, names):
    dic = {}
    dic['action'] = []
    dic['category'] = []

    for name in names:

        ##error occurs sometimes. check error first. if yes skip
        try:
            a.get_intent_filters(itemtype, name).items()

        except:
            continue

        for key, android_names in a.get_intent_filters(itemtype, name).items():
            if key == 'action':
                dic['action'].append(android_names)
            if key == 'category':
                dic['category'].append(android_names)

    if dic['action']:
        dic['action'] = np.concatenate(dic['action'])
    if dic['category']:
        dic['category'] = np.concatenate(dic['category'])

    return dic


if __name__ == "__main__":
    main()
