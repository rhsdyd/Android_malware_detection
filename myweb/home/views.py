import os

from django.core.files.storage import FileSystemStorage
from django.shortcuts import render
from django.http import HttpResponse
from androguard.misc import AnalyzeAPK
import re
import requests
import json
import numpy as np

# Create your views here.

def index(request):
    if request.method == "POST":
        msg = "h1"
        file = request.FILES['apk']
        fname = file.name
        if fname.endswith(".apk"):
            fs = FileSystemStorage()
            f = fs.save(fname, file)
            uploaded_file_url = fs.url(f)
            print(uploaded_file_url)
            file_path = os.path.join('./myweb' + uploaded_file_url)
            try:
                print('waiting')
                a, d, dx = AnalyzeAPK(file_path)

                body = extractFeature(a, dx)

                name = a.get_package()
                body['app_name'] = name
                url = 'http://localhost:5000'
                x = requests.post(url, data=body)
                result = x.json()
                msg = result['response']

                if os.path.isfile(file_path):
                    os.remove(file_path )
            except Exception:
                if os.path.isfile(file_path):
                    os.remove(file_path )
                name = "error"
                msg = "not run-able apk"

        else:
            name = "error"
            msg = 'upload apk'
        return render(request, 'home/result.html', context={'message': msg, 'name': name})
    else:
        return render(request, 'home/index.html')


def get_relevantPart_xml(string):
    splits = string.split(".")
    return splits[len(splits) - 1]


def get_relevantPart_class(string):
    splits = string.split("/")
    return splits[len(splits) - 1]


def deduplication(feature_list):
    toset = set(feature_list)
    feature_list = list(toset)
    return feature_list

def extractIntentFilters(a, itemtype, names):
    dic = {}
    dic['action'] = []
    dic['category'] = []

    for name in names:

        ##error occurs sometimes. check error first. if yes skip
        try:
            a.get_intent_filters(itemtype, name).items()

        except:
            continue

        for key, android_names in a.get_intent_filters(itemtype, name).items():
            if key == 'action':
                dic['action'].append([get_relevantPart_xml(android_name) for android_name in android_names])

            if key == 'category':
                dic['category'].append([get_relevantPart_xml(android_name) for android_name in android_names])

    if dic['action']:
        dic['action'] = np.concatenate(dic['action'])
    if dic['category']:
        dic['category'] = np.concatenate(dic['category'])

    return dic


def cleanAPIList(api_list, isclass=False):
    new_api_list = []
    if isclass:
        api_list = list(map(lambda x: get_relevantPart_class(x), api_list))
    for comp in api_list:
        if isclass:
            comp = re.sub('\$(\w)+', '', comp)
            comp = re.sub(';$', '', comp)

        if re.match('^z{1,}\w*', comp) or re.match('^\$', comp):
            continue

        if len(comp) > 3 and comp[0] != '<':
            new_api_list.append(comp)

    return deduplication(new_api_list)


def extractFeature(a, dx):
    static_analysis_dic = {}
    all_actions = []
    all_categories = []

    ## permission features
    try:
        permissions = list(map(lambda x: get_relevantPart_xml(x), a.get_permissions()))
        static_analysis_dic['permissions'] = deduplication(permissions)
    except UnicodeEncodeError:
        print("No permission has been extracted")

    ## activity features
    try:
        activities = a.get_activities()
        result_activities = extractIntentFilters(a, 'activity', activities)
        all_actions.append(result_activities['action'])
        all_categories.append(result_activities['category'])
        matched_activities = list(map(lambda x: get_relevantPart_xml(x), activities))
        static_analysis_dic['activities'] = deduplication(matched_activities)
    except UnicodeEncodeError:
        print("No activity has been extracted")

    ## service
    try:
        services = a.get_services()
        result_services = extractIntentFilters(a, 'service', services)
        all_actions.append(result_services['action'])
        all_categories.append(result_services['category'])
        matched_services = list(map(lambda x: get_relevantPart_xml(x), services))
        static_analysis_dic['services'] = deduplication(matched_services)
    except UnicodeEncodeError:
        print("No service has been extracted")

    ## receiver
    try:
        receivers = a.get_receivers()
        result_receivers = extractIntentFilters(a, 'receiver', receivers)
        all_actions.append(result_receivers['action'])
        all_categories.append(result_receivers['category'])
        matched_receivers = list(map(lambda x: get_relevantPart_xml(x), receivers))
        static_analysis_dic['receivers'] = deduplication(matched_receivers)
    except UnicodeEncodeError:
        print("No receiver has been extracted")

    static_analysis_dic['intent-actions'] = deduplication(np.concatenate(all_actions))
    static_analysis_dic['intent-categories'] = deduplication(np.concatenate(all_categories))

    ##Get processed bytecode from decompiler
    ##API methods
    method_list = []
    try:
        for method in dx.get_methods():
            if method.is_external():
                m = method.get_method()
                method_list.append(str(m.get_name()))
        method_list = cleanAPIList(method_list)
        static_analysis_dic['API_methods'] = method_list
    except UnicodeEncodeError:
        print("Error while extracting API class")

    '''
    ##API classes including package names
    class_list = []
    try:
        for method in dx.get_methods():
            if method.is_external():
                m = method.get_method()
                class_list.append(str(m.get_class_name()))
        class_list = cleanAPIList(class_list, True)
        static_analysis_dic['API_classes'] = class_list
    except UnicodeEncodeError:
        print("Error while extracting API class")
    '''

    return static_analysis_dic
