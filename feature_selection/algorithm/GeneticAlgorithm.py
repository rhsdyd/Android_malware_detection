import random
import copy
import numpy as np
from operator import attrgetter
import sys

'''
reference: https://github.com/remiomosowon/pyeasyga
'''


class GeneticAlgorithm(object):
    def __init__(self,
                 data,
                 label,
                 fitness,
                 population_size=20,
                 children_size=20,
                 generations=15,
                 recombination_probability=0.8,
                 mutation_probability=0.2,
                 tournament_size=4,
                 survivor_strategy='plus',
                 recombination_strategy='point',
                 maximise_fitness=True,
                 random_state=None):
        """Instantiate the Genetic Algorithm.
        :param seed_data: input data to the Genetic Algorithm
        :type seed_data: pandas Dataframe
        :param int population_size: size of population
        :param int generations: number of generations to evolve
        :param float recombination_probability: probability of recombination operation
        :param float mutation_probability: probability of mutation operation
        :param int tournament_size: size of tournament
        :param string survivor_strategy: strategy of survivor selection (plus or comma)
        :param string recombination_strategy: strategy of recombination operation (point or uniform)
        :param int: random seed. defaults to None
        """

        self.seed_data = data
        self.label = label
        self.fitness = fitness
        self.population_size = population_size
        self.children_size = children_size
        self.generations = generations
        self.recombination_probability = recombination_probability
        self.mutation_probability = mutation_probability
        self.tournament_size = tournament_size
        self.survivor_strategy = survivor_strategy
        self.recombination_strategy = recombination_strategy
        self.maximise_fitness = maximise_fitness

        # seed random number generator
        self.random = random.Random(random_state)

        # Run Genetic Algorithm
        self.current_generation = []
        self.iteration_fitness = []
        self.iteration_ncol = []
        self.create_initial_population()
        self.sort_population()
        print("iteration: %s ---- Fitness: %f ---#NumCol: %s" % (
            1, self.current_generation[0].fitness, self.current_generation[0].ncol))
        self.pre = self.current_generation
        self.iteration_fitness.append(self.current_generation[0].fitness)
        self.iteration_ncol.append(self.current_generation[0].ncol)

        for i in range(1, self.generations):
            self.create_new_children()
            self.select_new_generation()
            print("iteration: %s ---- Fitness: %f ---#NumCol: %s" % (
                i + 1, self.current_generation[0].fitness, self.current_generation[0].ncol))

            self.iteration_fitness.append(self.current_generation[0].fitness)
            self.iteration_ncol.append(self.current_generation[0].ncol)
            self.pre = self.current_generation

    def create_initial_population(self):
        """Create the first population randomly.
        """
        initial_population = []
        for _ in range(self.population_size):
            indices = [self.random.randint(0, 1) for _ in range(len(self.seed_data.columns))]
            individual = Individual(indices)
            col = self.seed_data.columns[np.array(individual.gene, dtype=bool)]
            individual.fitness = self.fitness(self.seed_data[col], self.label)
            initial_population.append(individual)
        self.current_generation = initial_population

    def sort_population(self):
        """Rank population according to its number of features and fitness score
        """
        self.current_generation.sort(key=attrgetter('ncol'), reverse=False)
        return self.current_generation.sort(key=attrgetter('fitness'), reverse=self.maximise_fitness)

    def create_new_children(self):
        """Create new children based on recombination and mutation operations
        """
        self.new_children = []
        size = self.children_size
        while size > 0:
            parent1 = self.tournament_selection()
            parent2 = self.tournament_selection()

            do_recomb = self.random.random() < self.recombination_probability

            if do_recomb:
                child1, child2 = self.crossover_function(parent1, parent2)

                self.new_children.append(child1)
                size = size - 1

                if size > 0:
                    self.new_children.append(child2)
                    size = size - 1

    def select_new_generation(self):
        """Select individuals which pass to the next generation
        """
        if self.survivor_strategy == 'plus':
            self.current_generation = self.new_children + self.current_generation

        elif self.survivor_strategy == 'comma':
            if self.children_size < self.population_size:
                sys.exit("children_size have to be greater than or equal to population_size")
            self.current_generation = self.new_children

        self.sort_population()
        self.current_generation = self.current_generation[0:self.population_size]

    def tournament_selection(self):
        """Select a k number of individual out of current generation.
        return the individual with the best fitness score
        """
        if self.tournament_size == 0:
            self.tournament_size = 4
        members = self.random.sample(self.current_generation, self.tournament_size)
        members.sort(key=attrgetter('ncol'), reverse=False)
        members.sort(key=attrgetter('fitness'), reverse=self.maximise_fitness)
        return members[0]

    def crossover_function(self, parent1, parent2):

        if self.recombination_strategy == 'point':
            index = self.random.randrange(1, len(parent1.gene))
            child1 = parent1.gene[:index] + parent2.gene[index:]

        elif self.recombination_strategy == 'uniform':
            child1 = [random.choice([parent1.gene[i], parent2.gene[i]]) for i in range(len(parent1.gene))]

        do_mutate = self.random.random() < self.mutation_probability
        if do_mutate:
            child1 = self.mutate(child1)
        child1 = Individual(child1)
        col = self.seed_data.columns[np.array(child1.gene, dtype=bool)]
        child1.fitness = self.fitness(self.seed_data[col], self.label)

        if self.recombination_strategy == 'point':
            child2 = parent1.gene[index:] + parent2.gene[:index]

        elif self.recombination_strategy == 'uniform':
            child2 = child1
            for i in range(len(child2)):
                child2[i] = (0, 1)[child1[i] == 0]

        do_mutate = self.random.random() < self.mutation_probability
        if do_mutate:
            child2 = self.mutate(child2)
        child2 = Individual(child2)
        col = self.seed_data.columns[np.array(child2.gene, dtype=bool)]
        child2.fitness = self.fitness(self.seed_data[col], self.label)

        return child1, child2

    def mutate(self, child):
        """Run bit-filp mutation
        """
        k = self.random.randrange(1, len(child))
        indices = np.random.randint(len(child), size=k)
        for idx in indices:
            child[idx] = (0, 1)[child == 0]

        return child

    def get_best_individual(self):
        """Return the features of individual with the best fitness in the last generation.
        """
        return self.seed_data.columns[np.array(self.current_generation[0].gene, dtype=bool)]


class Individual:
    def __init__(self, gene):
        self.gene = gene
        self.fitness = 0
        self.ncol = sum(gene)
