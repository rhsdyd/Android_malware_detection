import fnmatch
import os.path
import argparse
import pandas as pd
from androguard.misc import AnalyzeAPK
import json
import re
from db import dbconn


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("-s", "--source", type=str, help="the directory of apk source folder", required=True)
    parser.add_argument("-db", "--database", default=False, action="store_true", help="use MySQL database or not",
                        required=False)
    args = parser.parse_args()

    source_folder_path = args.source
    benign_path = 'benign'
    malware_path = 'malware'
    ## prepare database
    if args.database:
        global conn, cur

        conn = dbconn()
        cur = conn.cursor()

        print("---- MySQL connected ----")

        ##if there is existing table, data will be appended
        sql = "SHOW TABLES"
        cur.execute(sql)
        result = cur.fetchall()
        exist = 0
        for i in result:
            if 'extractedFeatures' in i:
                exist = 1
                break
        if exist:
            print("TABLE name \"extractedFeatures\" already exists")
        else:
            print("create TABLE extractedFeatures")
            sql = "CREATE TABLE extractedFeatures (" \
                  "id INT NOT NULL AUTO_INCREMENT," \
                  "app_name VARCHAR(225)," \
                  "label varchar(225)," \
                  "features LONGTEXT," \
                  "PRIMARY KEY (id)" \
                  ");"
            print(sql)
            cur.execute(sql)
            conn.commit()

    ##start extraction processe
    benign_df = extractFeatures(source_folder_path, benign_path, args.database)
    malware_df = extractFeatures(source_folder_path, malware_path, args.database)
    output_df = benign_df.append(malware_df)
    output_df.to_csv('csv_results/extracted_features.csv', index=False)


def extractFeatures(source_folder_path, label_path, use_db):
    print("----- start " + label_path + " apps -----")
    ## get list of apk file
    file_list = os.listdir(source_folder_path + '/' + label_path)

    features_df = pd.DataFrame()

    ## Run extraction process if the file format is .apk
    for file in file_list:
        # check file format whether it is apk or not
        if fnmatch.fnmatch(file, '*.apk'):
            print("Run Feature extraction from {}".format(file))
            file_path = os.path.join(source_folder_path, label_path, file)
            try:
                a, d, dx = AnalyzeAPK(file_path)
            except Exception:
                print("ERROR in APK:" + file)

            a.get_package()
            static_analysis_dic = {}

            ## permission features
            try:
                permissions = list(map(lambda x: get_relevantPart_xml(x), a.get_permissions()))
                static_analysis_dic['permissions'] = deduplication(permissions)
            except UnicodeEncodeError:
                print("No permission has been extracted")

            ## activity features
            try:
                activities = list(map(lambda x: get_relevantPart_xml(x), a.get_activities()))
                static_analysis_dic['activities'] = deduplication(activities)
            except UnicodeEncodeError:
                print("No activity has been extracted")

            ## service
            try:
                services = list(map(lambda x: get_relevantPart_xml(x), a.get_services()))
                static_analysis_dic['services'] = deduplication(services)
            except UnicodeEncodeError:
                print("No service has been extracted")

            ## receiver
            try:
                receivers = list(map(lambda x: get_relevantPart_xml(x), a.get_receivers()))
                static_analysis_dic['receivers'] = deduplication(receivers)
            except UnicodeEncodeError:
                print("No receiver has been extracted")

            ##Get processed bytecode from decompiler
            ##API methods
            method_list = []
            try:
                for method in dx.get_methods():
                    if method.is_external():
                        m = method.get_method()
                        method_list.append(str(m.get_name()))
                method_list = cleanAPIList(method_list)
                static_analysis_dic['API_methods'] = method_list
            except UnicodeEncodeError:
                print("Error while extracting API class")

            ##API classes including package names
            class_list = []
            try:
                for method in dx.get_methods():
                    if method.is_external():
                        m = method.get_method()
                        class_list.append(str(m.get_class_name()))
                class_list = cleanAPIList(class_list, True)
                static_analysis_dic['API_classes'] = class_list
            except UnicodeEncodeError:
                print("Error while extracting API class")

            json_features = json.dumps(static_analysis_dic)

            df = pd.DataFrame({'app_name': [a.get_package()],
                               'label': [label_path],
                               'features': [json_features]})

            if use_db:
                sql = "INSERT INTO extractedFeatures (app_name, label, features) VALUES('" + str(df.iloc[0][0]) + "', '" \
                      + str(df.iloc[0][1]) + "', '" + json_features + "'); "
                cur.execute(sql)
                conn.commit()

            features_df = features_df.append(df)
        else:
            print("wrong file format")
    return features_df


def get_relevantPart_xml(string):
    splits = string.split(".")
    return splits[len(splits) - 1]


def get_relevantPart_class(string):
    splits = string.split("/")
    return splits[len(splits) - 1]


def deduplication(feature_list):
    toset = set(feature_list)
    feature_list = list(toset)
    return feature_list


def cleanAPIList(api_list, isclass=False):
    new_api_list = []
    if isclass:
        api_list = list(map(lambda x: get_relevantPart_class(x), api_list))
    for comp in api_list:
        if isclass:
            comp = re.sub('\$(\w)+', '', comp)
            comp = re.sub(';$', '', comp)

        if re.match('^z{1,}\w*', comp):
            continue

        if len(comp) > 3 and comp[0] != '<':
            new_api_list.append(comp)

    return deduplication(new_api_list)


if __name__ == "__main__":
    main()
